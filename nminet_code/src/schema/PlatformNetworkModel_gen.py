#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated  by generateDS.py.
#
# Command line options:
#   ('--no-dates', '')
#   ('--no-versions', '')
#   ('--silence', '')
#   ('-f', '')
#   ('-o', 'PlatformNetworkModel_gen.py')
#
# Command line arguments:
#   ../../../service/schema/PlatformNetworkModel.xsd
#
# Command line:
#   ../../bin/generateDS.py --no-dates --no-versions --silence -f -o "PlatformNetworkModel_gen.py" ../../../service/schema/PlatformNetworkModel.xsd
#
# Current working directory (os.getcwd()):
#   schema
#

import sys
import re as re_
import base64
import datetime as datetime_
import warnings as warnings_


Validate_simpletypes_ = True


etree_ = None
Verbose_import_ = False
(
    XMLParser_import_none, XMLParser_import_lxml,
    XMLParser_import_elementtree
) = range(3)
XMLParser_import_library = None
try:
    # lxml
    from lxml import etree as etree_
    XMLParser_import_library = XMLParser_import_lxml
    if Verbose_import_:
        print("running with lxml.etree")
except ImportError:
    try:
        # cElementTree from Python 2.5+
        import xml.etree.cElementTree as etree_
        XMLParser_import_library = XMLParser_import_elementtree
        if Verbose_import_:
            print("running with cElementTree on Python 2.5+")
    except ImportError:
        try:
            # ElementTree from Python 2.5+
            import xml.etree.ElementTree as etree_
            XMLParser_import_library = XMLParser_import_elementtree
            if Verbose_import_:
                print("running with ElementTree on Python 2.5+")
        except ImportError:
            try:
                # normal cElementTree install
                import cElementTree as etree_
                XMLParser_import_library = XMLParser_import_elementtree
                if Verbose_import_:
                    print("running with cElementTree")
            except ImportError:
                try:
                    # normal ElementTree install
                    import elementtree.ElementTree as etree_
                    XMLParser_import_library = XMLParser_import_elementtree
                    if Verbose_import_:
                        print("running with ElementTree")
                except ImportError:
                    raise ImportError(
                        "Failed to import ElementTree from any known place")


def parsexml_(*args, **kwargs):
    if (XMLParser_import_library == XMLParser_import_lxml and
            'parser' not in kwargs):
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        kwargs['parser'] = etree_.ETCompatXMLParser()
    doc = etree_.parse(*args, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError, exp:

    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_validate_float(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (time_parts[0], micro_seconds, )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.  We should:
            # - AND the outer elements
            # - OR the inner elements
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    if re_.search(patterns2, target) is not None:
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.iteritems()))


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'ascii'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    if not inStr:
        return ''
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    if XMLParser_import_library == XMLParser_import_lxml:
        msg = '%s (element %s/line %d)' % (
            msg, node.tag, node.sourceline, )
    else:
        msg = '%s (element %s)' % (msg, node.tag, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace, pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace, name, pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name, base64.b64encode(self.value), self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class PlatformNetworkModel(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DNSServers=None, DNSDomains=None, NTPServers=None, EnableBootP=None, EthernetPortConfigModels=None):
        self.original_tagname_ = None
        self.DNSServers = DNSServers
        self.DNSDomains = DNSDomains
        self.NTPServers = NTPServers
        self.EnableBootP = EnableBootP
        if EthernetPortConfigModels is None:
            self.EthernetPortConfigModels = []
        else:
            self.EthernetPortConfigModels = EthernetPortConfigModels
    def factory(*args_, **kwargs_):
        if PlatformNetworkModel.subclass:
            return PlatformNetworkModel.subclass(*args_, **kwargs_)
        else:
            return PlatformNetworkModel(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DNSServers(self): return self.DNSServers
    def set_DNSServers(self, DNSServers): self.DNSServers = DNSServers
    def get_DNSDomains(self): return self.DNSDomains
    def set_DNSDomains(self, DNSDomains): self.DNSDomains = DNSDomains
    def get_NTPServers(self): return self.NTPServers
    def set_NTPServers(self, NTPServers): self.NTPServers = NTPServers
    def get_EnableBootP(self): return self.EnableBootP
    def set_EnableBootP(self, EnableBootP): self.EnableBootP = EnableBootP
    def get_EthernetPortConfigModels(self): return self.EthernetPortConfigModels
    def set_EthernetPortConfigModels(self, EthernetPortConfigModels): self.EthernetPortConfigModels = EthernetPortConfigModels
    def add_EthernetPortConfigModels(self, value): self.EthernetPortConfigModels.append(value)
    def insert_EthernetPortConfigModels_at(self, index, value): self.EthernetPortConfigModels.insert(index, value)
    def replace_EthernetPortConfigModels_at(self, index, value): self.EthernetPortConfigModels[index] = value
    def hasContent_(self):
        if (
            self.DNSServers is not None or
            self.DNSDomains is not None or
            self.NTPServers is not None or
            self.EnableBootP is not None or
            self.EthernetPortConfigModels
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PlatformNetworkModel', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PlatformNetworkModel')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PlatformNetworkModel', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PlatformNetworkModel'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PlatformNetworkModel', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DNSServers is not None:
            self.DNSServers.export(outfile, level, namespace_, name_='DNSServers', pretty_print=pretty_print)
        if self.DNSDomains is not None:
            self.DNSDomains.export(outfile, level, namespace_, name_='DNSDomains', pretty_print=pretty_print)
        if self.NTPServers is not None:
            self.NTPServers.export(outfile, level, namespace_, name_='NTPServers', pretty_print=pretty_print)
        if self.EnableBootP is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEnableBootP>%s</%sEnableBootP>%s' % (namespace_, self.gds_format_boolean(self.EnableBootP, input_name='EnableBootP'), namespace_, eol_))
        for EthernetPortConfigModels_ in self.EthernetPortConfigModels:
            EthernetPortConfigModels_.export(outfile, level, namespace_, name_='EthernetPortConfigModels', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='PlatformNetworkModel'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.DNSServers is not None:
            showIndent(outfile, level)
            outfile.write('DNSServers=model_.DNSServersType(\n')
            self.DNSServers.exportLiteral(outfile, level, name_='DNSServers')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DNSDomains is not None:
            showIndent(outfile, level)
            outfile.write('DNSDomains=model_.DNSDomainsType(\n')
            self.DNSDomains.exportLiteral(outfile, level, name_='DNSDomains')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.NTPServers is not None:
            showIndent(outfile, level)
            outfile.write('NTPServers=model_.NTPServersType(\n')
            self.NTPServers.exportLiteral(outfile, level, name_='NTPServers')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.EnableBootP is not None:
            showIndent(outfile, level)
            outfile.write('EnableBootP=%s,\n' % self.EnableBootP)
        showIndent(outfile, level)
        outfile.write('EthernetPortConfigModels=[\n')
        level += 1
        for EthernetPortConfigModels_ in self.EthernetPortConfigModels:
            showIndent(outfile, level)
            outfile.write('model_.EthernetPortConfigModelsType(\n')
            EthernetPortConfigModels_.exportLiteral(outfile, level, name_='EthernetPortConfigModelsType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DNSServers':
            obj_ = DNSServersType.factory()
            obj_.build(child_)
            self.DNSServers = obj_
            obj_.original_tagname_ = 'DNSServers'
        elif nodeName_ == 'DNSDomains':
            obj_ = DNSDomainsType.factory()
            obj_.build(child_)
            self.DNSDomains = obj_
            obj_.original_tagname_ = 'DNSDomains'
        elif nodeName_ == 'NTPServers':
            obj_ = NTPServersType.factory()
            obj_.build(child_)
            self.NTPServers = obj_
            obj_.original_tagname_ = 'NTPServers'
        elif nodeName_ == 'EnableBootP':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'EnableBootP')
            self.EnableBootP = ival_
        elif nodeName_ == 'EthernetPortConfigModels':
            obj_ = EthernetPortConfigModelsType.factory()
            obj_.build(child_)
            self.EthernetPortConfigModels.append(obj_)
            obj_.original_tagname_ = 'EthernetPortConfigModels'
# end class PlatformNetworkModel


class DNSServersType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, IPAddressWithEthernetPortClass=None):
        self.original_tagname_ = None
        if IPAddressWithEthernetPortClass is None:
            self.IPAddressWithEthernetPortClass = []
        else:
            self.IPAddressWithEthernetPortClass = IPAddressWithEthernetPortClass
    def factory(*args_, **kwargs_):
        if DNSServersType.subclass:
            return DNSServersType.subclass(*args_, **kwargs_)
        else:
            return DNSServersType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_IPAddressWithEthernetPortClass(self): return self.IPAddressWithEthernetPortClass
    def set_IPAddressWithEthernetPortClass(self, IPAddressWithEthernetPortClass): self.IPAddressWithEthernetPortClass = IPAddressWithEthernetPortClass
    def add_IPAddressWithEthernetPortClass(self, value): self.IPAddressWithEthernetPortClass.append(value)
    def insert_IPAddressWithEthernetPortClass_at(self, index, value): self.IPAddressWithEthernetPortClass.insert(index, value)
    def replace_IPAddressWithEthernetPortClass_at(self, index, value): self.IPAddressWithEthernetPortClass[index] = value
    def hasContent_(self):
        if (
            self.IPAddressWithEthernetPortClass
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DNSServersType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DNSServersType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DNSServersType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DNSServersType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DNSServersType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for IPAddressWithEthernetPortClass_ in self.IPAddressWithEthernetPortClass:
            IPAddressWithEthernetPortClass_.export(outfile, level, namespace_, name_='IPAddressWithEthernetPortClass', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='DNSServersType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('IPAddressWithEthernetPortClass=[\n')
        level += 1
        for IPAddressWithEthernetPortClass_ in self.IPAddressWithEthernetPortClass:
            showIndent(outfile, level)
            outfile.write('model_.IPAddressWithEthernetPortClassType(\n')
            IPAddressWithEthernetPortClass_.exportLiteral(outfile, level, name_='IPAddressWithEthernetPortClassType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'IPAddressWithEthernetPortClass':
            obj_ = IPAddressWithEthernetPortClassType.factory()
            obj_.build(child_)
            self.IPAddressWithEthernetPortClass.append(obj_)
            obj_.original_tagname_ = 'IPAddressWithEthernetPortClass'
# end class DNSServersType


class IPAddressWithEthernetPortClassType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, IPAddress=None, EthernetPort=None, Origin=None):
        self.original_tagname_ = None
        self.IPAddress = IPAddress
        self.EthernetPort = EthernetPort
        self.Origin = Origin
        self.validate_OriginType(self.Origin)
    def factory(*args_, **kwargs_):
        if IPAddressWithEthernetPortClassType.subclass:
            return IPAddressWithEthernetPortClassType.subclass(*args_, **kwargs_)
        else:
            return IPAddressWithEthernetPortClassType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_IPAddress(self): return self.IPAddress
    def set_IPAddress(self, IPAddress): self.IPAddress = IPAddress
    def get_EthernetPort(self): return self.EthernetPort
    def set_EthernetPort(self, EthernetPort): self.EthernetPort = EthernetPort
    def get_Origin(self): return self.Origin
    def set_Origin(self, Origin): self.Origin = Origin
    def validate_OriginType(self, value):
        # Validate type OriginType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            enumerations = ['Manual', 'DHCP']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on OriginType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.IPAddress is not None or
            self.EthernetPort is not None or
            self.Origin is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IPAddressWithEthernetPortClassType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IPAddressWithEthernetPortClassType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IPAddressWithEthernetPortClassType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IPAddressWithEthernetPortClassType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='IPAddressWithEthernetPortClassType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.IPAddress is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIPAddress>%s</%sIPAddress>%s' % (namespace_, self.gds_format_string(quote_xml(self.IPAddress).encode(ExternalEncoding), input_name='IPAddress'), namespace_, eol_))
        if self.EthernetPort is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEthernetPort>%s</%sEthernetPort>%s' % (namespace_, self.gds_format_string(quote_xml(self.EthernetPort).encode(ExternalEncoding), input_name='EthernetPort'), namespace_, eol_))
        if self.Origin is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOrigin>%s</%sOrigin>%s' % (namespace_, self.gds_format_string(quote_xml(self.Origin).encode(ExternalEncoding), input_name='Origin'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='IPAddressWithEthernetPortClassType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.IPAddress is not None:
            showIndent(outfile, level)
            outfile.write('IPAddress=%s,\n' % quote_python(self.IPAddress).encode(ExternalEncoding))
        if self.EthernetPort is not None:
            showIndent(outfile, level)
            outfile.write('EthernetPort=%s,\n' % quote_python(self.EthernetPort).encode(ExternalEncoding))
        if self.Origin is not None:
            showIndent(outfile, level)
            outfile.write('Origin=%s,\n' % quote_python(self.Origin).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'IPAddress':
            IPAddress_ = child_.text
            IPAddress_ = self.gds_validate_string(IPAddress_, node, 'IPAddress')
            self.IPAddress = IPAddress_
        elif nodeName_ == 'EthernetPort':
            EthernetPort_ = child_.text
            EthernetPort_ = self.gds_validate_string(EthernetPort_, node, 'EthernetPort')
            self.EthernetPort = EthernetPort_
        elif nodeName_ == 'Origin':
            Origin_ = child_.text
            Origin_ = self.gds_validate_string(Origin_, node, 'Origin')
            self.Origin = Origin_
            self.validate_OriginType(self.Origin)    # validate type OriginType
# end class IPAddressWithEthernetPortClassType


class DNSDomainsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, IPAddressOrDomainNameClass=None):
        self.original_tagname_ = None
        if IPAddressOrDomainNameClass is None:
            self.IPAddressOrDomainNameClass = []
        else:
            self.IPAddressOrDomainNameClass = IPAddressOrDomainNameClass
    def factory(*args_, **kwargs_):
        if DNSDomainsType.subclass:
            return DNSDomainsType.subclass(*args_, **kwargs_)
        else:
            return DNSDomainsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_IPAddressOrDomainNameClass(self): return self.IPAddressOrDomainNameClass
    def set_IPAddressOrDomainNameClass(self, IPAddressOrDomainNameClass): self.IPAddressOrDomainNameClass = IPAddressOrDomainNameClass
    def add_IPAddressOrDomainNameClass(self, value): self.IPAddressOrDomainNameClass.append(value)
    def insert_IPAddressOrDomainNameClass_at(self, index, value): self.IPAddressOrDomainNameClass.insert(index, value)
    def replace_IPAddressOrDomainNameClass_at(self, index, value): self.IPAddressOrDomainNameClass[index] = value
    def hasContent_(self):
        if (
            self.IPAddressOrDomainNameClass
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DNSDomainsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DNSDomainsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DNSDomainsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DNSDomainsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DNSDomainsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for IPAddressOrDomainNameClass_ in self.IPAddressOrDomainNameClass:
            IPAddressOrDomainNameClass_.export(outfile, level, namespace_, name_='IPAddressOrDomainNameClass', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='DNSDomainsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('IPAddressOrDomainNameClass=[\n')
        level += 1
        for IPAddressOrDomainNameClass_ in self.IPAddressOrDomainNameClass:
            showIndent(outfile, level)
            outfile.write('model_.IPAddressOrDomainNameClassType(\n')
            IPAddressOrDomainNameClass_.exportLiteral(outfile, level, name_='IPAddressOrDomainNameClassType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'IPAddressOrDomainNameClass':
            obj_ = IPAddressOrDomainNameClassType.factory()
            obj_.build(child_)
            self.IPAddressOrDomainNameClass.append(obj_)
            obj_.original_tagname_ = 'IPAddressOrDomainNameClass'
# end class DNSDomainsType


class IPAddressOrDomainNameClassType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, IPAddress=None):
        self.original_tagname_ = None
        self.IPAddress = IPAddress
    def factory(*args_, **kwargs_):
        if IPAddressOrDomainNameClassType.subclass:
            return IPAddressOrDomainNameClassType.subclass(*args_, **kwargs_)
        else:
            return IPAddressOrDomainNameClassType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_IPAddress(self): return self.IPAddress
    def set_IPAddress(self, IPAddress): self.IPAddress = IPAddress
    def hasContent_(self):
        if (
            self.IPAddress is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IPAddressOrDomainNameClassType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IPAddressOrDomainNameClassType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IPAddressOrDomainNameClassType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IPAddressOrDomainNameClassType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='IPAddressOrDomainNameClassType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.IPAddress is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIPAddress>%s</%sIPAddress>%s' % (namespace_, self.gds_format_string(quote_xml(self.IPAddress).encode(ExternalEncoding), input_name='IPAddress'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='IPAddressOrDomainNameClassType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.IPAddress is not None:
            showIndent(outfile, level)
            outfile.write('IPAddress=%s,\n' % quote_python(self.IPAddress).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'IPAddress':
            IPAddress_ = child_.text
            IPAddress_ = self.gds_validate_string(IPAddress_, node, 'IPAddress')
            self.IPAddress = IPAddress_
# end class IPAddressOrDomainNameClassType


class NTPServersType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, IPAddressOrDomainNameClass=None):
        self.original_tagname_ = None
        if IPAddressOrDomainNameClass is None:
            self.IPAddressOrDomainNameClass = []
        else:
            self.IPAddressOrDomainNameClass = IPAddressOrDomainNameClass
    def factory(*args_, **kwargs_):
        if NTPServersType.subclass:
            return NTPServersType.subclass(*args_, **kwargs_)
        else:
            return NTPServersType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_IPAddressOrDomainNameClass(self): return self.IPAddressOrDomainNameClass
    def set_IPAddressOrDomainNameClass(self, IPAddressOrDomainNameClass): self.IPAddressOrDomainNameClass = IPAddressOrDomainNameClass
    def add_IPAddressOrDomainNameClass(self, value): self.IPAddressOrDomainNameClass.append(value)
    def insert_IPAddressOrDomainNameClass_at(self, index, value): self.IPAddressOrDomainNameClass.insert(index, value)
    def replace_IPAddressOrDomainNameClass_at(self, index, value): self.IPAddressOrDomainNameClass[index] = value
    def hasContent_(self):
        if (
            self.IPAddressOrDomainNameClass
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NTPServersType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NTPServersType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NTPServersType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NTPServersType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='NTPServersType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for IPAddressOrDomainNameClass_ in self.IPAddressOrDomainNameClass:
            IPAddressOrDomainNameClass_.export(outfile, level, namespace_, name_='IPAddressOrDomainNameClass', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='NTPServersType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('IPAddressOrDomainNameClass=[\n')
        level += 1
        for IPAddressOrDomainNameClass_ in self.IPAddressOrDomainNameClass:
            showIndent(outfile, level)
            outfile.write('model_.IPAddressOrDomainNameClassType1(\n')
            IPAddressOrDomainNameClass_.exportLiteral(outfile, level, name_='IPAddressOrDomainNameClassType1')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'IPAddressOrDomainNameClass':
            obj_ = IPAddressOrDomainNameClassType1.factory()
            obj_.build(child_)
            self.IPAddressOrDomainNameClass.append(obj_)
            obj_.original_tagname_ = 'IPAddressOrDomainNameClass'
# end class NTPServersType


class IPAddressOrDomainNameClassType1(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, IPAddress=None):
        self.original_tagname_ = None
        self.IPAddress = IPAddress
    def factory(*args_, **kwargs_):
        if IPAddressOrDomainNameClassType1.subclass:
            return IPAddressOrDomainNameClassType1.subclass(*args_, **kwargs_)
        else:
            return IPAddressOrDomainNameClassType1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_IPAddress(self): return self.IPAddress
    def set_IPAddress(self, IPAddress): self.IPAddress = IPAddress
    def hasContent_(self):
        if (
            self.IPAddress is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IPAddressOrDomainNameClassType1', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IPAddressOrDomainNameClassType1')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IPAddressOrDomainNameClassType1', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IPAddressOrDomainNameClassType1'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='IPAddressOrDomainNameClassType1', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.IPAddress is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIPAddress>%s</%sIPAddress>%s' % (namespace_, self.gds_format_string(quote_xml(self.IPAddress).encode(ExternalEncoding), input_name='IPAddress'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='IPAddressOrDomainNameClassType1'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.IPAddress is not None:
            showIndent(outfile, level)
            outfile.write('IPAddress=%s,\n' % quote_python(self.IPAddress).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'IPAddress':
            IPAddress_ = child_.text
            IPAddress_ = self.gds_validate_string(IPAddress_, node, 'IPAddress')
            self.IPAddress = IPAddress_
# end class IPAddressOrDomainNameClassType1


class EthernetPortConfigModelsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, EthernetPortConfigModel=None):
        self.original_tagname_ = None
        if EthernetPortConfigModel is None:
            self.EthernetPortConfigModel = []
        else:
            self.EthernetPortConfigModel = EthernetPortConfigModel
    def factory(*args_, **kwargs_):
        if EthernetPortConfigModelsType.subclass:
            return EthernetPortConfigModelsType.subclass(*args_, **kwargs_)
        else:
            return EthernetPortConfigModelsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_EthernetPortConfigModel(self): return self.EthernetPortConfigModel
    def set_EthernetPortConfigModel(self, EthernetPortConfigModel): self.EthernetPortConfigModel = EthernetPortConfigModel
    def add_EthernetPortConfigModel(self, value): self.EthernetPortConfigModel.append(value)
    def insert_EthernetPortConfigModel_at(self, index, value): self.EthernetPortConfigModel.insert(index, value)
    def replace_EthernetPortConfigModel_at(self, index, value): self.EthernetPortConfigModel[index] = value
    def hasContent_(self):
        if (
            self.EthernetPortConfigModel
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='EthernetPortConfigModelsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EthernetPortConfigModelsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='EthernetPortConfigModelsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EthernetPortConfigModelsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='EthernetPortConfigModelsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for EthernetPortConfigModel_ in self.EthernetPortConfigModel:
            EthernetPortConfigModel_.export(outfile, level, namespace_, name_='EthernetPortConfigModel', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='EthernetPortConfigModelsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('EthernetPortConfigModel=[\n')
        level += 1
        for EthernetPortConfigModel_ in self.EthernetPortConfigModel:
            showIndent(outfile, level)
            outfile.write('model_.EthernetPortConfigModelType(\n')
            EthernetPortConfigModel_.exportLiteral(outfile, level, name_='EthernetPortConfigModelType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'EthernetPortConfigModel':
            obj_ = EthernetPortConfigModelType.factory()
            obj_.build(child_)
            self.EthernetPortConfigModel.append(obj_)
            obj_.original_tagname_ = 'EthernetPortConfigModel'
# end class EthernetPortConfigModelsType


class EthernetPortConfigModelType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, PortIdentifier=None, PCIDeviceLocation=None, Name=None, PortStatus=None, EnableInterface=None, EnableDHCP=None, EnableRedundancy=None, RedundancyMode=None, RedundantPortType=None, RedundancyStatus=None, AutoNegotiate=None, IsManualPrimaryPort=None, IPAddress=None, IPAddressModels=None, ActiveMAC=None, NetworkMask=None, Gateway=None, GatewayModels=None, LinkSpeed=None, Utilization=None, CanEnableRedundancy=None, ModelKey=None, EnableDHCPMethod=None, InterfaceRoles=None, FollowerKeys=None, CandidateRoles=None, PlatformObjectID=None):
        self.original_tagname_ = None
        self.PortIdentifier = PortIdentifier
        self.PCIDeviceLocation = PCIDeviceLocation
        self.Name = Name
        self.PortStatus = PortStatus
        self.validate_PortStatusType(self.PortStatus)
        self.EnableInterface = EnableInterface
        self.EnableDHCP = EnableDHCP
        self.EnableRedundancy = EnableRedundancy
        self.RedundancyMode = RedundancyMode
        self.validate_RedundancyModeType(self.RedundancyMode)
        self.RedundantPortType = RedundantPortType
        self.validate_RedundantPortTypeType(self.RedundantPortType)
        self.RedundancyStatus = RedundancyStatus
        self.validate_RedundancyStatusType(self.RedundancyStatus)
        self.AutoNegotiate = AutoNegotiate
        self.validate_AutoNegotiateType(self.AutoNegotiate)
        self.IsManualPrimaryPort = IsManualPrimaryPort
        self.IPAddress = IPAddress
        self.IPAddressModels = IPAddressModels
        self.ActiveMAC = ActiveMAC
        self.NetworkMask = NetworkMask
        self.Gateway = Gateway
        self.GatewayModels = GatewayModels
        self.LinkSpeed = LinkSpeed
        self.Utilization = Utilization
        self.CanEnableRedundancy = CanEnableRedundancy
        self.ModelKey = ModelKey
        self.EnableDHCPMethod = EnableDHCPMethod
        if InterfaceRoles is None:
            self.InterfaceRoles = []
        else:
            self.InterfaceRoles = InterfaceRoles
        if FollowerKeys is None:
            self.FollowerKeys = []
        else:
            self.FollowerKeys = FollowerKeys
        if CandidateRoles is None:
            self.CandidateRoles = []
        else:
            self.CandidateRoles = CandidateRoles
        self.PlatformObjectID = PlatformObjectID
    def factory(*args_, **kwargs_):
        if EthernetPortConfigModelType.subclass:
            return EthernetPortConfigModelType.subclass(*args_, **kwargs_)
        else:
            return EthernetPortConfigModelType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PortIdentifier(self): return self.PortIdentifier
    def set_PortIdentifier(self, PortIdentifier): self.PortIdentifier = PortIdentifier
    def get_PCIDeviceLocation(self): return self.PCIDeviceLocation
    def set_PCIDeviceLocation(self, PCIDeviceLocation): self.PCIDeviceLocation = PCIDeviceLocation
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_PortStatus(self): return self.PortStatus
    def set_PortStatus(self, PortStatus): self.PortStatus = PortStatus
    def get_EnableInterface(self): return self.EnableInterface
    def set_EnableInterface(self, EnableInterface): self.EnableInterface = EnableInterface
    def get_EnableDHCP(self): return self.EnableDHCP
    def set_EnableDHCP(self, EnableDHCP): self.EnableDHCP = EnableDHCP
    def get_EnableRedundancy(self): return self.EnableRedundancy
    def set_EnableRedundancy(self, EnableRedundancy): self.EnableRedundancy = EnableRedundancy
    def get_RedundancyMode(self): return self.RedundancyMode
    def set_RedundancyMode(self, RedundancyMode): self.RedundancyMode = RedundancyMode
    def get_RedundantPortType(self): return self.RedundantPortType
    def set_RedundantPortType(self, RedundantPortType): self.RedundantPortType = RedundantPortType
    def get_RedundancyStatus(self): return self.RedundancyStatus
    def set_RedundancyStatus(self, RedundancyStatus): self.RedundancyStatus = RedundancyStatus
    def get_AutoNegotiate(self): return self.AutoNegotiate
    def set_AutoNegotiate(self, AutoNegotiate): self.AutoNegotiate = AutoNegotiate
    def get_IsManualPrimaryPort(self): return self.IsManualPrimaryPort
    def set_IsManualPrimaryPort(self, IsManualPrimaryPort): self.IsManualPrimaryPort = IsManualPrimaryPort
    def get_IPAddress(self): return self.IPAddress
    def set_IPAddress(self, IPAddress): self.IPAddress = IPAddress
    def get_IPAddressModels(self): return self.IPAddressModels
    def set_IPAddressModels(self, IPAddressModels): self.IPAddressModels = IPAddressModels
    def get_ActiveMAC(self): return self.ActiveMAC
    def set_ActiveMAC(self, ActiveMAC): self.ActiveMAC = ActiveMAC
    def get_NetworkMask(self): return self.NetworkMask
    def set_NetworkMask(self, NetworkMask): self.NetworkMask = NetworkMask
    def get_Gateway(self): return self.Gateway
    def set_Gateway(self, Gateway): self.Gateway = Gateway
    def get_GatewayModels(self): return self.GatewayModels
    def set_GatewayModels(self, GatewayModels): self.GatewayModels = GatewayModels
    def get_LinkSpeed(self): return self.LinkSpeed
    def set_LinkSpeed(self, LinkSpeed): self.LinkSpeed = LinkSpeed
    def get_Utilization(self): return self.Utilization
    def set_Utilization(self, Utilization): self.Utilization = Utilization
    def get_CanEnableRedundancy(self): return self.CanEnableRedundancy
    def set_CanEnableRedundancy(self, CanEnableRedundancy): self.CanEnableRedundancy = CanEnableRedundancy
    def get_ModelKey(self): return self.ModelKey
    def set_ModelKey(self, ModelKey): self.ModelKey = ModelKey
    def get_EnableDHCPMethod(self): return self.EnableDHCPMethod
    def set_EnableDHCPMethod(self, EnableDHCPMethod): self.EnableDHCPMethod = EnableDHCPMethod
    def get_InterfaceRoles(self): return self.InterfaceRoles
    def set_InterfaceRoles(self, InterfaceRoles): self.InterfaceRoles = InterfaceRoles
    def add_InterfaceRoles(self, value): self.InterfaceRoles.append(value)
    def insert_InterfaceRoles_at(self, index, value): self.InterfaceRoles.insert(index, value)
    def replace_InterfaceRoles_at(self, index, value): self.InterfaceRoles[index] = value
    def get_FollowerKeys(self): return self.FollowerKeys
    def set_FollowerKeys(self, FollowerKeys): self.FollowerKeys = FollowerKeys
    def add_FollowerKeys(self, value): self.FollowerKeys.append(value)
    def insert_FollowerKeys_at(self, index, value): self.FollowerKeys.insert(index, value)
    def replace_FollowerKeys_at(self, index, value): self.FollowerKeys[index] = value
    def get_CandidateRoles(self): return self.CandidateRoles
    def set_CandidateRoles(self, CandidateRoles): self.CandidateRoles = CandidateRoles
    def add_CandidateRoles(self, value): self.CandidateRoles.append(value)
    def insert_CandidateRoles_at(self, index, value): self.CandidateRoles.insert(index, value)
    def replace_CandidateRoles_at(self, index, value): self.CandidateRoles[index] = value
    def get_PlatformObjectID(self): return self.PlatformObjectID
    def set_PlatformObjectID(self, PlatformObjectID): self.PlatformObjectID = PlatformObjectID
    def validate_PortStatusType(self, value):
        # Validate type PortStatusType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            enumerations = ['CONNECTED', 'DISABLED', 'MEDIA_DISCONNECTED']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on PortStatusType' % {"value" : value.encode("utf-8")} )
    def validate_RedundancyModeType(self, value):
        # Validate type RedundancyModeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            enumerations = ['AUTOMATIC', 'AUTOMATIC_REVERT', 'MANUAL', 'MANUAL_NOFAILOVER', 'DUAL']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on RedundancyModeType' % {"value" : value.encode("utf-8")} )
    def validate_RedundantPortTypeType(self, value):
        # Validate type RedundantPortTypeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            enumerations = ['ACTIVE_ACTIVE', 'ACTIVE_STANDBY']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on RedundantPortTypeType' % {"value" : value.encode("utf-8")} )
    def validate_RedundancyStatusType(self, value):
        # Validate type RedundancyStatusType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            enumerations = ['NOT_ENABLED', 'ACTIVE', 'INACTIVE', 'DISCONNECTED']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on RedundancyStatusType' % {"value" : value.encode("utf-8")} )
    def validate_AutoNegotiateType(self, value):
        # Validate type AutoNegotiateType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            enumerations = ['AUTO_NEGOTIATE', 'FORCE_TENG_FULL', 'FORCE_ONEG_FULL', 'FORCE_HUNDM_FULL', 'OTHER']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AutoNegotiateType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.PortIdentifier is not None or
            self.PCIDeviceLocation is not None or
            self.Name is not None or
            self.PortStatus is not None or
            self.EnableInterface is not None or
            self.EnableDHCP is not None or
            self.EnableRedundancy is not None or
            self.RedundancyMode is not None or
            self.RedundantPortType is not None or
            self.RedundancyStatus is not None or
            self.AutoNegotiate is not None or
            self.IsManualPrimaryPort is not None or
            self.IPAddress is not None or
            self.IPAddressModels is not None or
            self.ActiveMAC is not None or
            self.NetworkMask is not None or
            self.Gateway is not None or
            self.GatewayModels is not None or
            self.LinkSpeed is not None or
            self.Utilization is not None or
            self.CanEnableRedundancy is not None or
            self.ModelKey is not None or
            self.EnableDHCPMethod is not None or
            self.InterfaceRoles or
            self.FollowerKeys or
            self.CandidateRoles or
            self.PlatformObjectID is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='EthernetPortConfigModelType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EthernetPortConfigModelType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='EthernetPortConfigModelType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EthernetPortConfigModelType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='EthernetPortConfigModelType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.PortIdentifier is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPortIdentifier>%s</%sPortIdentifier>%s' % (namespace_, self.gds_format_integer(self.PortIdentifier, input_name='PortIdentifier'), namespace_, eol_))
        if self.PCIDeviceLocation is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPCIDeviceLocation>%s</%sPCIDeviceLocation>%s' % (namespace_, self.gds_format_string(quote_xml(self.PCIDeviceLocation).encode(ExternalEncoding), input_name='PCIDeviceLocation'), namespace_, eol_))
        if self.Name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sName>%s</%sName>%s' % (namespace_, self.gds_format_string(quote_xml(self.Name).encode(ExternalEncoding), input_name='Name'), namespace_, eol_))
        if self.PortStatus is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPortStatus>%s</%sPortStatus>%s' % (namespace_, self.gds_format_string(quote_xml(self.PortStatus).encode(ExternalEncoding), input_name='PortStatus'), namespace_, eol_))
        if self.EnableInterface is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEnableInterface>%s</%sEnableInterface>%s' % (namespace_, self.gds_format_boolean(self.EnableInterface, input_name='EnableInterface'), namespace_, eol_))
        if self.EnableDHCP is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEnableDHCP>%s</%sEnableDHCP>%s' % (namespace_, self.gds_format_boolean(self.EnableDHCP, input_name='EnableDHCP'), namespace_, eol_))
        if self.EnableRedundancy is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEnableRedundancy>%s</%sEnableRedundancy>%s' % (namespace_, self.gds_format_boolean(self.EnableRedundancy, input_name='EnableRedundancy'), namespace_, eol_))
        if self.RedundancyMode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRedundancyMode>%s</%sRedundancyMode>%s' % (namespace_, self.gds_format_string(quote_xml(self.RedundancyMode).encode(ExternalEncoding), input_name='RedundancyMode'), namespace_, eol_))
        if self.RedundantPortType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRedundantPortType>%s</%sRedundantPortType>%s' % (namespace_, self.gds_format_string(quote_xml(self.RedundantPortType).encode(ExternalEncoding), input_name='RedundantPortType'), namespace_, eol_))
        if self.RedundancyStatus is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRedundancyStatus>%s</%sRedundancyStatus>%s' % (namespace_, self.gds_format_string(quote_xml(self.RedundancyStatus).encode(ExternalEncoding), input_name='RedundancyStatus'), namespace_, eol_))
        if self.AutoNegotiate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAutoNegotiate>%s</%sAutoNegotiate>%s' % (namespace_, self.gds_format_string(quote_xml(self.AutoNegotiate).encode(ExternalEncoding), input_name='AutoNegotiate'), namespace_, eol_))
        if self.IsManualPrimaryPort is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIsManualPrimaryPort>%s</%sIsManualPrimaryPort>%s' % (namespace_, self.gds_format_boolean(self.IsManualPrimaryPort, input_name='IsManualPrimaryPort'), namespace_, eol_))
        if self.IPAddress is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIPAddress>%s</%sIPAddress>%s' % (namespace_, self.gds_format_string(quote_xml(self.IPAddress).encode(ExternalEncoding), input_name='IPAddress'), namespace_, eol_))
        if self.IPAddressModels is not None:
            self.IPAddressModels.export(outfile, level, namespace_, name_='IPAddressModels', pretty_print=pretty_print)
        if self.ActiveMAC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sActiveMAC>%s</%sActiveMAC>%s' % (namespace_, self.gds_format_string(quote_xml(self.ActiveMAC).encode(ExternalEncoding), input_name='ActiveMAC'), namespace_, eol_))
        if self.NetworkMask is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNetworkMask>%s</%sNetworkMask>%s' % (namespace_, self.gds_format_string(quote_xml(self.NetworkMask).encode(ExternalEncoding), input_name='NetworkMask'), namespace_, eol_))
        if self.Gateway is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGateway>%s</%sGateway>%s' % (namespace_, self.gds_format_string(quote_xml(self.Gateway).encode(ExternalEncoding), input_name='Gateway'), namespace_, eol_))
        if self.GatewayModels is not None:
            self.GatewayModels.export(outfile, level, namespace_, name_='GatewayModels', pretty_print=pretty_print)
        if self.LinkSpeed is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLinkSpeed>%s</%sLinkSpeed>%s' % (namespace_, self.gds_format_string(quote_xml(self.LinkSpeed).encode(ExternalEncoding), input_name='LinkSpeed'), namespace_, eol_))
        if self.Utilization is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUtilization>%s</%sUtilization>%s' % (namespace_, self.gds_format_string(quote_xml(self.Utilization).encode(ExternalEncoding), input_name='Utilization'), namespace_, eol_))
        if self.CanEnableRedundancy is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCanEnableRedundancy>%s</%sCanEnableRedundancy>%s' % (namespace_, self.gds_format_boolean(self.CanEnableRedundancy, input_name='CanEnableRedundancy'), namespace_, eol_))
        if self.ModelKey is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sModelKey>%s</%sModelKey>%s' % (namespace_, self.gds_format_integer(self.ModelKey, input_name='ModelKey'), namespace_, eol_))
        if self.EnableDHCPMethod is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEnableDHCPMethod>%s</%sEnableDHCPMethod>%s' % (namespace_, self.gds_format_boolean(self.EnableDHCPMethod, input_name='EnableDHCPMethod'), namespace_, eol_))
        for InterfaceRoles_ in self.InterfaceRoles:
            InterfaceRoles_.export(outfile, level, namespace_, name_='InterfaceRoles', pretty_print=pretty_print)
        for FollowerKeys_ in self.FollowerKeys:
            FollowerKeys_.export(outfile, level, namespace_, name_='FollowerKeys', pretty_print=pretty_print)
        for CandidateRoles_ in self.CandidateRoles:
            CandidateRoles_.export(outfile, level, namespace_, name_='CandidateRoles', pretty_print=pretty_print)
        if self.PlatformObjectID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPlatformObjectID>%s</%sPlatformObjectID>%s' % (namespace_, self.gds_format_string(quote_xml(self.PlatformObjectID).encode(ExternalEncoding), input_name='PlatformObjectID'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='EthernetPortConfigModelType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.PortIdentifier is not None:
            showIndent(outfile, level)
            outfile.write('PortIdentifier=%d,\n' % self.PortIdentifier)
        if self.PCIDeviceLocation is not None:
            showIndent(outfile, level)
            outfile.write('PCIDeviceLocation=%s,\n' % quote_python(self.PCIDeviceLocation).encode(ExternalEncoding))
        if self.Name is not None:
            showIndent(outfile, level)
            outfile.write('Name=%s,\n' % quote_python(self.Name).encode(ExternalEncoding))
        if self.PortStatus is not None:
            showIndent(outfile, level)
            outfile.write('PortStatus=%s,\n' % quote_python(self.PortStatus).encode(ExternalEncoding))
        if self.EnableInterface is not None:
            showIndent(outfile, level)
            outfile.write('EnableInterface=%s,\n' % self.EnableInterface)
        if self.EnableDHCP is not None:
            showIndent(outfile, level)
            outfile.write('EnableDHCP=%s,\n' % self.EnableDHCP)
        if self.EnableRedundancy is not None:
            showIndent(outfile, level)
            outfile.write('EnableRedundancy=%s,\n' % self.EnableRedundancy)
        if self.RedundancyMode is not None:
            showIndent(outfile, level)
            outfile.write('RedundancyMode=%s,\n' % quote_python(self.RedundancyMode).encode(ExternalEncoding))
        if self.RedundantPortType is not None:
            showIndent(outfile, level)
            outfile.write('RedundantPortType=%s,\n' % quote_python(self.RedundantPortType).encode(ExternalEncoding))
        if self.RedundancyStatus is not None:
            showIndent(outfile, level)
            outfile.write('RedundancyStatus=%s,\n' % quote_python(self.RedundancyStatus).encode(ExternalEncoding))
        if self.AutoNegotiate is not None:
            showIndent(outfile, level)
            outfile.write('AutoNegotiate=%s,\n' % quote_python(self.AutoNegotiate).encode(ExternalEncoding))
        if self.IsManualPrimaryPort is not None:
            showIndent(outfile, level)
            outfile.write('IsManualPrimaryPort=%s,\n' % self.IsManualPrimaryPort)
        if self.IPAddress is not None:
            showIndent(outfile, level)
            outfile.write('IPAddress=%s,\n' % quote_python(self.IPAddress).encode(ExternalEncoding))
        if self.IPAddressModels is not None:
            showIndent(outfile, level)
            outfile.write('IPAddressModels=model_.IPAddressModelsType(\n')
            self.IPAddressModels.exportLiteral(outfile, level, name_='IPAddressModels')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ActiveMAC is not None:
            showIndent(outfile, level)
            outfile.write('ActiveMAC=%s,\n' % quote_python(self.ActiveMAC).encode(ExternalEncoding))
        if self.NetworkMask is not None:
            showIndent(outfile, level)
            outfile.write('NetworkMask=%s,\n' % quote_python(self.NetworkMask).encode(ExternalEncoding))
        if self.Gateway is not None:
            showIndent(outfile, level)
            outfile.write('Gateway=%s,\n' % quote_python(self.Gateway).encode(ExternalEncoding))
        if self.GatewayModels is not None:
            showIndent(outfile, level)
            outfile.write('GatewayModels=model_.GatewayModelsType(\n')
            self.GatewayModels.exportLiteral(outfile, level, name_='GatewayModels')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.LinkSpeed is not None:
            showIndent(outfile, level)
            outfile.write('LinkSpeed=%s,\n' % quote_python(self.LinkSpeed).encode(ExternalEncoding))
        if self.Utilization is not None:
            showIndent(outfile, level)
            outfile.write('Utilization=%s,\n' % quote_python(self.Utilization).encode(ExternalEncoding))
        if self.CanEnableRedundancy is not None:
            showIndent(outfile, level)
            outfile.write('CanEnableRedundancy=%s,\n' % self.CanEnableRedundancy)
        if self.ModelKey is not None:
            showIndent(outfile, level)
            outfile.write('ModelKey=%d,\n' % self.ModelKey)
        if self.EnableDHCPMethod is not None:
            showIndent(outfile, level)
            outfile.write('EnableDHCPMethod=%s,\n' % self.EnableDHCPMethod)
        showIndent(outfile, level)
        outfile.write('InterfaceRoles=[\n')
        level += 1
        for InterfaceRoles_ in self.InterfaceRoles:
            showIndent(outfile, level)
            outfile.write('model_.InterfaceRolesType(\n')
            InterfaceRoles_.exportLiteral(outfile, level, name_='InterfaceRolesType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('FollowerKeys=[\n')
        level += 1
        for FollowerKeys_ in self.FollowerKeys:
            showIndent(outfile, level)
            outfile.write('model_.FollowerKeysType(\n')
            FollowerKeys_.exportLiteral(outfile, level, name_='FollowerKeysType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('CandidateRoles=[\n')
        level += 1
        for CandidateRoles_ in self.CandidateRoles:
            showIndent(outfile, level)
            outfile.write('model_.CandidateRolesType(\n')
            CandidateRoles_.exportLiteral(outfile, level, name_='CandidateRolesType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.PlatformObjectID is not None:
            showIndent(outfile, level)
            outfile.write('PlatformObjectID=%s,\n' % quote_python(self.PlatformObjectID).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PortIdentifier':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'PortIdentifier')
            self.PortIdentifier = ival_
        elif nodeName_ == 'PCIDeviceLocation':
            PCIDeviceLocation_ = child_.text
            PCIDeviceLocation_ = self.gds_validate_string(PCIDeviceLocation_, node, 'PCIDeviceLocation')
            self.PCIDeviceLocation = PCIDeviceLocation_
        elif nodeName_ == 'Name':
            Name_ = child_.text
            Name_ = self.gds_validate_string(Name_, node, 'Name')
            self.Name = Name_
        elif nodeName_ == 'PortStatus':
            PortStatus_ = child_.text
            PortStatus_ = self.gds_validate_string(PortStatus_, node, 'PortStatus')
            self.PortStatus = PortStatus_
            self.validate_PortStatusType(self.PortStatus)    # validate type PortStatusType
        elif nodeName_ == 'EnableInterface':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'EnableInterface')
            self.EnableInterface = ival_
        elif nodeName_ == 'EnableDHCP':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'EnableDHCP')
            self.EnableDHCP = ival_
        elif nodeName_ == 'EnableRedundancy':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'EnableRedundancy')
            self.EnableRedundancy = ival_
        elif nodeName_ == 'RedundancyMode':
            RedundancyMode_ = child_.text
            RedundancyMode_ = self.gds_validate_string(RedundancyMode_, node, 'RedundancyMode')
            self.RedundancyMode = RedundancyMode_
            self.validate_RedundancyModeType(self.RedundancyMode)    # validate type RedundancyModeType
        elif nodeName_ == 'RedundantPortType':
            RedundantPortType_ = child_.text
            RedundantPortType_ = self.gds_validate_string(RedundantPortType_, node, 'RedundantPortType')
            self.RedundantPortType = RedundantPortType_
            self.validate_RedundantPortTypeType(self.RedundantPortType)    # validate type RedundantPortTypeType
        elif nodeName_ == 'RedundancyStatus':
            RedundancyStatus_ = child_.text
            RedundancyStatus_ = self.gds_validate_string(RedundancyStatus_, node, 'RedundancyStatus')
            self.RedundancyStatus = RedundancyStatus_
            self.validate_RedundancyStatusType(self.RedundancyStatus)    # validate type RedundancyStatusType
        elif nodeName_ == 'AutoNegotiate':
            AutoNegotiate_ = child_.text
            AutoNegotiate_ = self.gds_validate_string(AutoNegotiate_, node, 'AutoNegotiate')
            self.AutoNegotiate = AutoNegotiate_
            self.validate_AutoNegotiateType(self.AutoNegotiate)    # validate type AutoNegotiateType
        elif nodeName_ == 'IsManualPrimaryPort':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'IsManualPrimaryPort')
            self.IsManualPrimaryPort = ival_
        elif nodeName_ == 'IPAddress':
            IPAddress_ = child_.text
            IPAddress_ = self.gds_validate_string(IPAddress_, node, 'IPAddress')
            self.IPAddress = IPAddress_
        elif nodeName_ == 'IPAddressModels':
            obj_ = IPAddressModelsType.factory()
            obj_.build(child_)
            self.IPAddressModels = obj_
            obj_.original_tagname_ = 'IPAddressModels'
        elif nodeName_ == 'ActiveMAC':
            ActiveMAC_ = child_.text
            ActiveMAC_ = self.gds_validate_string(ActiveMAC_, node, 'ActiveMAC')
            self.ActiveMAC = ActiveMAC_
        elif nodeName_ == 'NetworkMask':
            NetworkMask_ = child_.text
            NetworkMask_ = self.gds_validate_string(NetworkMask_, node, 'NetworkMask')
            self.NetworkMask = NetworkMask_
        elif nodeName_ == 'Gateway':
            Gateway_ = child_.text
            Gateway_ = self.gds_validate_string(Gateway_, node, 'Gateway')
            self.Gateway = Gateway_
        elif nodeName_ == 'GatewayModels':
            obj_ = GatewayModelsType.factory()
            obj_.build(child_)
            self.GatewayModels = obj_
            obj_.original_tagname_ = 'GatewayModels'
        elif nodeName_ == 'LinkSpeed':
            LinkSpeed_ = child_.text
            LinkSpeed_ = self.gds_validate_string(LinkSpeed_, node, 'LinkSpeed')
            self.LinkSpeed = LinkSpeed_
        elif nodeName_ == 'Utilization':
            Utilization_ = child_.text
            Utilization_ = self.gds_validate_string(Utilization_, node, 'Utilization')
            self.Utilization = Utilization_
        elif nodeName_ == 'CanEnableRedundancy':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'CanEnableRedundancy')
            self.CanEnableRedundancy = ival_
        elif nodeName_ == 'ModelKey':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ModelKey')
            self.ModelKey = ival_
        elif nodeName_ == 'EnableDHCPMethod':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'EnableDHCPMethod')
            self.EnableDHCPMethod = ival_
        elif nodeName_ == 'InterfaceRoles':
            obj_ = InterfaceRolesType.factory()
            obj_.build(child_)
            self.InterfaceRoles.append(obj_)
            obj_.original_tagname_ = 'InterfaceRoles'
        elif nodeName_ == 'FollowerKeys':
            obj_ = FollowerKeysType.factory()
            obj_.build(child_)
            self.FollowerKeys.append(obj_)
            obj_.original_tagname_ = 'FollowerKeys'
        elif nodeName_ == 'CandidateRoles':
            obj_ = CandidateRolesType.factory()
            obj_.build(child_)
            self.CandidateRoles.append(obj_)
            obj_.original_tagname_ = 'CandidateRoles'
        elif nodeName_ == 'PlatformObjectID':
            PlatformObjectID_ = child_.text
            PlatformObjectID_ = self.gds_validate_string(PlatformObjectID_, node, 'PlatformObjectID')
            self.PlatformObjectID = PlatformObjectID_
# end class EthernetPortConfigModelType


class IPAddressModelsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, IPAddressModel=None):
        self.original_tagname_ = None
        if IPAddressModel is None:
            self.IPAddressModel = []
        else:
            self.IPAddressModel = IPAddressModel
    def factory(*args_, **kwargs_):
        if IPAddressModelsType.subclass:
            return IPAddressModelsType.subclass(*args_, **kwargs_)
        else:
            return IPAddressModelsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_IPAddressModel(self): return self.IPAddressModel
    def set_IPAddressModel(self, IPAddressModel): self.IPAddressModel = IPAddressModel
    def add_IPAddressModel(self, value): self.IPAddressModel.append(value)
    def insert_IPAddressModel_at(self, index, value): self.IPAddressModel.insert(index, value)
    def replace_IPAddressModel_at(self, index, value): self.IPAddressModel[index] = value
    def hasContent_(self):
        if (
            self.IPAddressModel
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IPAddressModelsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IPAddressModelsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IPAddressModelsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IPAddressModelsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='IPAddressModelsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for IPAddressModel_ in self.IPAddressModel:
            IPAddressModel_.export(outfile, level, namespace_, name_='IPAddressModel', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='IPAddressModelsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('IPAddressModel=[\n')
        level += 1
        for IPAddressModel_ in self.IPAddressModel:
            showIndent(outfile, level)
            outfile.write('model_.IPAddressModelType(\n')
            IPAddressModel_.exportLiteral(outfile, level, name_='IPAddressModelType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'IPAddressModel':
            obj_ = IPAddressModelType.factory()
            obj_.build(child_)
            self.IPAddressModel.append(obj_)
            obj_.original_tagname_ = 'IPAddressModel'
# end class IPAddressModelsType


class IPAddressModelType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, IPAddress=None, AddressOrigin=None):
        self.original_tagname_ = None
        self.IPAddress = IPAddress
        self.AddressOrigin = AddressOrigin
        self.validate_AddressOriginType(self.AddressOrigin)
    def factory(*args_, **kwargs_):
        if IPAddressModelType.subclass:
            return IPAddressModelType.subclass(*args_, **kwargs_)
        else:
            return IPAddressModelType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_IPAddress(self): return self.IPAddress
    def set_IPAddress(self, IPAddress): self.IPAddress = IPAddress
    def get_AddressOrigin(self): return self.AddressOrigin
    def set_AddressOrigin(self, AddressOrigin): self.AddressOrigin = AddressOrigin
    def validate_AddressOriginType(self, value):
        # Validate type AddressOriginType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            enumerations = ['Unknown', 'LinkLocal', 'RouterAdvertisement', 'Manual', 'DHCP']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AddressOriginType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.IPAddress is not None or
            self.AddressOrigin is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IPAddressModelType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IPAddressModelType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IPAddressModelType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IPAddressModelType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='IPAddressModelType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.IPAddress is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIPAddress>%s</%sIPAddress>%s' % (namespace_, self.gds_format_string(quote_xml(self.IPAddress).encode(ExternalEncoding), input_name='IPAddress'), namespace_, eol_))
        if self.AddressOrigin is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAddressOrigin>%s</%sAddressOrigin>%s' % (namespace_, self.gds_format_string(quote_xml(self.AddressOrigin).encode(ExternalEncoding), input_name='AddressOrigin'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='IPAddressModelType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.IPAddress is not None:
            showIndent(outfile, level)
            outfile.write('IPAddress=%s,\n' % quote_python(self.IPAddress).encode(ExternalEncoding))
        if self.AddressOrigin is not None:
            showIndent(outfile, level)
            outfile.write('AddressOrigin=%s,\n' % quote_python(self.AddressOrigin).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'IPAddress':
            IPAddress_ = child_.text
            IPAddress_ = self.gds_validate_string(IPAddress_, node, 'IPAddress')
            self.IPAddress = IPAddress_
        elif nodeName_ == 'AddressOrigin':
            AddressOrigin_ = child_.text
            AddressOrigin_ = self.gds_validate_string(AddressOrigin_, node, 'AddressOrigin')
            self.AddressOrigin = AddressOrigin_
            self.validate_AddressOriginType(self.AddressOrigin)    # validate type AddressOriginType
# end class IPAddressModelType


class GatewayModelsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, GatewayModel=None):
        self.original_tagname_ = None
        if GatewayModel is None:
            self.GatewayModel = []
        else:
            self.GatewayModel = GatewayModel
    def factory(*args_, **kwargs_):
        if GatewayModelsType.subclass:
            return GatewayModelsType.subclass(*args_, **kwargs_)
        else:
            return GatewayModelsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_GatewayModel(self): return self.GatewayModel
    def set_GatewayModel(self, GatewayModel): self.GatewayModel = GatewayModel
    def add_GatewayModel(self, value): self.GatewayModel.append(value)
    def insert_GatewayModel_at(self, index, value): self.GatewayModel.insert(index, value)
    def replace_GatewayModel_at(self, index, value): self.GatewayModel[index] = value
    def hasContent_(self):
        if (
            self.GatewayModel
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='GatewayModelsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GatewayModelsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='GatewayModelsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GatewayModelsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='GatewayModelsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for GatewayModel_ in self.GatewayModel:
            GatewayModel_.export(outfile, level, namespace_, name_='GatewayModel', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='GatewayModelsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('GatewayModel=[\n')
        level += 1
        for GatewayModel_ in self.GatewayModel:
            showIndent(outfile, level)
            outfile.write('model_.GatewayModelType(\n')
            GatewayModel_.exportLiteral(outfile, level, name_='GatewayModelType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'GatewayModel':
            obj_ = GatewayModelType.factory()
            obj_.build(child_)
            self.GatewayModel.append(obj_)
            obj_.original_tagname_ = 'GatewayModel'
# end class GatewayModelsType


class GatewayModelType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, GatewayAddress=None, GatewayOrigin=None):
        self.original_tagname_ = None
        self.GatewayAddress = GatewayAddress
        self.GatewayOrigin = GatewayOrigin
        self.validate_GatewayOriginType(self.GatewayOrigin)
    def factory(*args_, **kwargs_):
        if GatewayModelType.subclass:
            return GatewayModelType.subclass(*args_, **kwargs_)
        else:
            return GatewayModelType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_GatewayAddress(self): return self.GatewayAddress
    def set_GatewayAddress(self, GatewayAddress): self.GatewayAddress = GatewayAddress
    def get_GatewayOrigin(self): return self.GatewayOrigin
    def set_GatewayOrigin(self, GatewayOrigin): self.GatewayOrigin = GatewayOrigin
    def validate_GatewayOriginType(self, value):
        # Validate type GatewayOriginType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            enumerations = ['Unknown', 'RouterAdvertisement', 'Manual', 'DHCP']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on GatewayOriginType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.GatewayAddress is not None or
            self.GatewayOrigin is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='GatewayModelType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GatewayModelType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='GatewayModelType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GatewayModelType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='GatewayModelType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.GatewayAddress is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGatewayAddress>%s</%sGatewayAddress>%s' % (namespace_, self.gds_format_string(quote_xml(self.GatewayAddress).encode(ExternalEncoding), input_name='GatewayAddress'), namespace_, eol_))
        if self.GatewayOrigin is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGatewayOrigin>%s</%sGatewayOrigin>%s' % (namespace_, self.gds_format_string(quote_xml(self.GatewayOrigin).encode(ExternalEncoding), input_name='GatewayOrigin'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='GatewayModelType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.GatewayAddress is not None:
            showIndent(outfile, level)
            outfile.write('GatewayAddress=%s,\n' % quote_python(self.GatewayAddress).encode(ExternalEncoding))
        if self.GatewayOrigin is not None:
            showIndent(outfile, level)
            outfile.write('GatewayOrigin=%s,\n' % quote_python(self.GatewayOrigin).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'GatewayAddress':
            GatewayAddress_ = child_.text
            GatewayAddress_ = self.gds_validate_string(GatewayAddress_, node, 'GatewayAddress')
            self.GatewayAddress = GatewayAddress_
        elif nodeName_ == 'GatewayOrigin':
            GatewayOrigin_ = child_.text
            GatewayOrigin_ = self.gds_validate_string(GatewayOrigin_, node, 'GatewayOrigin')
            self.GatewayOrigin = GatewayOrigin_
            self.validate_GatewayOriginType(self.GatewayOrigin)    # validate type GatewayOriginType
# end class GatewayModelType


class InterfaceRolesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, InterfaceRoleModel=None):
        self.original_tagname_ = None
        if InterfaceRoleModel is None:
            self.InterfaceRoleModel = []
        else:
            self.InterfaceRoleModel = InterfaceRoleModel
    def factory(*args_, **kwargs_):
        if InterfaceRolesType.subclass:
            return InterfaceRolesType.subclass(*args_, **kwargs_)
        else:
            return InterfaceRolesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_InterfaceRoleModel(self): return self.InterfaceRoleModel
    def set_InterfaceRoleModel(self, InterfaceRoleModel): self.InterfaceRoleModel = InterfaceRoleModel
    def add_InterfaceRoleModel(self, value): self.InterfaceRoleModel.append(value)
    def insert_InterfaceRoleModel_at(self, index, value): self.InterfaceRoleModel.insert(index, value)
    def replace_InterfaceRoleModel_at(self, index, value): self.InterfaceRoleModel[index] = value
    def hasContent_(self):
        if (
            self.InterfaceRoleModel
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='InterfaceRolesType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='InterfaceRolesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='InterfaceRolesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='InterfaceRolesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='InterfaceRolesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for InterfaceRoleModel_ in self.InterfaceRoleModel:
            InterfaceRoleModel_.export(outfile, level, namespace_, name_='InterfaceRoleModel', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='InterfaceRolesType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('InterfaceRoleModel=[\n')
        level += 1
        for InterfaceRoleModel_ in self.InterfaceRoleModel:
            showIndent(outfile, level)
            outfile.write('model_.InterfaceRoleModelType(\n')
            InterfaceRoleModel_.exportLiteral(outfile, level, name_='InterfaceRoleModelType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'InterfaceRoleModel':
            obj_ = InterfaceRoleModelType.factory()
            obj_.build(child_)
            self.InterfaceRoleModel.append(obj_)
            obj_.original_tagname_ = 'InterfaceRoleModel'
# end class InterfaceRolesType


class InterfaceRoleModelType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, InterfaceRole=None):
        self.original_tagname_ = None
        self.InterfaceRole = InterfaceRole
    def factory(*args_, **kwargs_):
        if InterfaceRoleModelType.subclass:
            return InterfaceRoleModelType.subclass(*args_, **kwargs_)
        else:
            return InterfaceRoleModelType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_InterfaceRole(self): return self.InterfaceRole
    def set_InterfaceRole(self, InterfaceRole): self.InterfaceRole = InterfaceRole
    def hasContent_(self):
        if (
            self.InterfaceRole is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='InterfaceRoleModelType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='InterfaceRoleModelType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='InterfaceRoleModelType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='InterfaceRoleModelType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='InterfaceRoleModelType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.InterfaceRole is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sInterfaceRole>%s</%sInterfaceRole>%s' % (namespace_, self.gds_format_string(quote_xml(self.InterfaceRole).encode(ExternalEncoding), input_name='InterfaceRole'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='InterfaceRoleModelType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.InterfaceRole is not None:
            showIndent(outfile, level)
            outfile.write('InterfaceRole=%s,\n' % quote_python(self.InterfaceRole).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'InterfaceRole':
            InterfaceRole_ = child_.text
            InterfaceRole_ = self.gds_validate_string(InterfaceRole_, node, 'InterfaceRole')
            self.InterfaceRole = InterfaceRole_
# end class InterfaceRoleModelType


class FollowerKeysType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, string=None):
        self.original_tagname_ = None
        self.string = string
    def factory(*args_, **kwargs_):
        if FollowerKeysType.subclass:
            return FollowerKeysType.subclass(*args_, **kwargs_)
        else:
            return FollowerKeysType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_string(self): return self.string
    def set_string(self, string): self.string = string
    def hasContent_(self):
        if (
            self.string is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FollowerKeysType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FollowerKeysType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FollowerKeysType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FollowerKeysType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='FollowerKeysType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.string is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstring>%s</%sstring>%s' % (namespace_, self.gds_format_integer(self.string, input_name='string'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='FollowerKeysType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.string is not None:
            showIndent(outfile, level)
            outfile.write('string=%d,\n' % self.string)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'string':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'string')
            self.string = ival_
# end class FollowerKeysType


class CandidateRolesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, string=None):
        self.original_tagname_ = None
        if string is None:
            self.string = []
        else:
            self.string = string
    def factory(*args_, **kwargs_):
        if CandidateRolesType.subclass:
            return CandidateRolesType.subclass(*args_, **kwargs_)
        else:
            return CandidateRolesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_string(self): return self.string
    def set_string(self, string): self.string = string
    def add_string(self, value): self.string.append(value)
    def insert_string_at(self, index, value): self.string.insert(index, value)
    def replace_string_at(self, index, value): self.string[index] = value
    def hasContent_(self):
        if (
            self.string
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CandidateRolesType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CandidateRolesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CandidateRolesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CandidateRolesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CandidateRolesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for string_ in self.string:
            string_.export(outfile, level, namespace_, name_='string', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='CandidateRolesType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('string=[\n')
        level += 1
        for string_ in self.string:
            showIndent(outfile, level)
            outfile.write('model_.stringType(\n')
            string_.exportLiteral(outfile, level, name_='stringType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'string':
            obj_ = stringType.factory()
            obj_.build(child_)
            self.string.append(obj_)
            obj_.original_tagname_ = 'string'
# end class CandidateRolesType


class stringType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, InterfaceRole=None):
        self.original_tagname_ = None
        self.InterfaceRole = InterfaceRole
    def factory(*args_, **kwargs_):
        if stringType.subclass:
            return stringType.subclass(*args_, **kwargs_)
        else:
            return stringType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_InterfaceRole(self): return self.InterfaceRole
    def set_InterfaceRole(self, InterfaceRole): self.InterfaceRole = InterfaceRole
    def hasContent_(self):
        if (
            self.InterfaceRole is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='stringType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='stringType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='stringType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='stringType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='stringType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.InterfaceRole is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sInterfaceRole>%s</%sInterfaceRole>%s' % (namespace_, self.gds_format_string(quote_xml(self.InterfaceRole).encode(ExternalEncoding), input_name='InterfaceRole'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='stringType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.InterfaceRole is not None:
            showIndent(outfile, level)
            outfile.write('InterfaceRole=%s,\n' % quote_python(self.InterfaceRole).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'InterfaceRole':
            InterfaceRole_ = child_.text
            InterfaceRole_ = self.gds_validate_string(InterfaceRole_, node, 'InterfaceRole')
            self.InterfaceRole = InterfaceRole_
# end class stringType


GDSClassesMapping = {
    'IPAddressModels': IPAddressModelsType,
    'IPAddressWithEthernetPortClass': IPAddressWithEthernetPortClassType,
    'string': stringType,
    'InterfaceRoles': InterfaceRolesType,
    'CandidateRoles': CandidateRolesType,
    'EthernetPortConfigModel': EthernetPortConfigModelType,
    'InterfaceRoleModel': InterfaceRoleModelType,
    'NTPServers': NTPServersType,
    'IPAddressModel': IPAddressModelType,
    'IPAddressOrDomainNameClass': IPAddressOrDomainNameClassType1,
    'FollowerKeys': FollowerKeysType,
    'GatewayModels': GatewayModelsType,
    'DNSDomains': DNSDomainsType,
    'EthernetPortConfigModels': EthernetPortConfigModelsType,
    'DNSServers': DNSServersType,
    'GatewayModel': GatewayModelType,
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print USAGE_TEXT
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'PlatformNetworkModel'
        rootClass = PlatformNetworkModel
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
##     if not silence:
##         sys.stdout.write('<?xml version="1.0" ?>\n')
##         rootObj.export(
##             sys.stdout, 0, name_=rootTag,
##             namespacedef_='',
##             pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'PlatformNetworkModel'
        rootClass = PlatformNetworkModel
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
##     if not silence:
##         content = etree_.tostring(
##             rootElement, pretty_print=True,
##             xml_declaration=True, encoding="utf-8")
##         sys.stdout.write(content)
##         sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    from StringIO import StringIO
    doc = parsexml_(StringIO(inString))
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'PlatformNetworkModel'
        rootClass = PlatformNetworkModel
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
##     if not silence:
##         sys.stdout.write('<?xml version="1.0" ?>\n')
##         rootObj.export(
##             sys.stdout, 0, name_=rootTag,
##             namespacedef_='')
    return rootObj


def parseLiteral(inFileName, silence=False):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'PlatformNetworkModel'
        rootClass = PlatformNetworkModel
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
##     if not silence:
##         sys.stdout.write('#from PlatformNetworkModel_gen import *\n\n')
##         sys.stdout.write('import PlatformNetworkModel_gen as model_\n\n')
##         sys.stdout.write('rootObj = model_.rootClass(\n')
##         rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
##         sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "CandidateRolesType",
    "DNSDomainsType",
    "DNSServersType",
    "EthernetPortConfigModelType",
    "EthernetPortConfigModelsType",
    "FollowerKeysType",
    "GatewayModelType",
    "GatewayModelsType",
    "IPAddressModelType",
    "IPAddressModelsType",
    "IPAddressOrDomainNameClassType",
    "IPAddressOrDomainNameClassType1",
    "IPAddressWithEthernetPortClassType",
    "InterfaceRoleModelType",
    "InterfaceRolesType",
    "NTPServersType",
    "PlatformNetworkModel",
    "stringType"
]
